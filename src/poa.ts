import { bytesToHex, Hex, hexToBytes } from "viem";
import { ExtendedWalletClient } from "./client";
import { getAddresses, NodeId, parseNodeID } from "./lib/utils";
import { SafeSuzakuContract } from "./lib/viemUtils";
import { setValidatorWeight } from "./lib/pChainUtils";
import { collectSignatures, packL1ValidatorRegistration, packWarpIntoAccessList } from "./lib/warpUtils";
import { color } from "console-log-colors";
import { GetRegistrationJustification } from "./lib/justification";
import { pChainChainID } from "./config";

export async function completValidatorRemoval(params: {
  client: ExtendedWalletClient;
  poaSecurityModule: SafeSuzakuContract['PoASecurityModule'];
  balancerSvc: SafeSuzakuContract['BalancerValidatorManager'];
  removeNodeTxHash: Hex;
  nodeId: NodeId;
  pchainTxPrivateKey: string;

}) {
  const { client, poaSecurityModule, balancerSvc, removeNodeTxHash, nodeId, pchainTxPrivateKey } = params;
  // Derive pchainTxAddress from the private key
  const { P: pchainTxAddress } = getAddresses(pchainTxPrivateKey, client.network);

  // TODO: Should create a new file for POA Security Module
  const receipt = await client.waitForTransactionReceipt({ hash: removeNodeTxHash })
  const loggedValidationID = receipt.logs[2].topics[1] ?? '';
  const nodeIdHex = parseNodeID(nodeId, false);
  const validationID = await balancerSvc.read.registeredValidators([nodeIdHex]);

  if (Number(validationID) > 0 && loggedValidationID === validationID) {// if the node is registered as a validator
    console.log(color.yellow("Node is not registered as a validator on the P-Chain, skipping setValidatorWeight call."));
  } else {
    // Get the unsigned L1ValidatorWeightMessage with weight=0 generated by the ValidatorManager from the receipt
    const unsignedL1ValidatorWeightMessage = receipt.logs[0].data ?? '';
    console.log("Initialize End Validation Warp Msg: ", unsignedL1ValidatorWeightMessage)

    // Aggregate signatures from validators
    // console.log("\nAggregating signatures for the L1ValidatorWeightMessage from the Validator Manager chain...");
    const signedL1ValidatorWeightMessage = await collectSignatures(client.network, unsignedL1ValidatorWeightMessage);
    console.log("Aggregated signatures for the L1ValidatorWeightMessage from the Validator Manager chain");

    // Call setValidatorWeight on the P-Chain with the signed L1ValidatorWeightMessage
    const pChainSetWeightTxId = await setValidatorWeight({
      privateKeyHex: pchainTxPrivateKey,
      client,
      validationID: validationID,
      message: signedL1ValidatorWeightMessage
    });
    console.log("SetL1ValidatorWeightTx executed on P-Chain:", pChainSetWeightTxId);
  }

  // get justification for original register validator tx (the unsigned warp msg emitted)
  const justification = await GetRegistrationJustification(nodeId, validationID, pChainChainID, client);

  // Pack and sign the P-Chain warp message
  const validationIDBytes = hexToBytes(validationID as Hex);
  const unsignedPChainWarpMsg = packL1ValidatorRegistration(validationIDBytes, false, 5, pChainChainID);
  const unsignedPChainWarpMsgHex = bytesToHex(unsignedPChainWarpMsg);

  // Aggregate signatures from validators
  // console.log("\nAggregating signatures for the L1ValidatorRegistrationMessage from the P-Chain...");
  const signedPChainMessage = await collectSignatures(client.network, unsignedPChainWarpMsgHex, bytesToHex(justification as Uint8Array));
  console.log("Aggregated signatures for the L1ValidatorRegistrationMessage from the P-Chain");

  // Convert the signed warp message to bytes and pack into access list
  const signedPChainWarpMsgBytes = hexToBytes(`0x${signedPChainMessage}`);
  const accessList = packWarpIntoAccessList(signedPChainWarpMsgBytes);

  const txHash = await poaSecurityModule.safeWrite.completeEndValidation([0], {
    chain: null,
    account: client.account!,
    accessList
  })
  return txHash;
}
